// Code generated by protoc-gen-go. DO NOT EDIT.
// source: geofences.proto

package geofence

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Status int32

const (
	Status_OK                    Status = 0
	Status_NOT_FOUND             Status = 1
	Status_BAD_REQUEST           Status = 2
	Status_INTERNAL_SERVER_ERROR Status = 3
)

var Status_name = map[int32]string{
	0: "OK",
	1: "NOT_FOUND",
	2: "BAD_REQUEST",
	3: "INTERNAL_SERVER_ERROR",
}

var Status_value = map[string]int32{
	"OK":                    0,
	"NOT_FOUND":             1,
	"BAD_REQUEST":           2,
	"INTERNAL_SERVER_ERROR": 3,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}

func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9b0d5848323ed639, []int{0}
}

// requests
type Point struct {
	PointId              uint64   `protobuf:"varint,1,opt,name=point_id,json=pointId,proto3" json:"point_id,omitempty"`
	Latitude             float64  `protobuf:"fixed64,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude            float64  `protobuf:"fixed64,3,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Accuracy             float64  `protobuf:"fixed64,4,opt,name=accuracy,proto3" json:"accuracy,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Point) Reset()         { *m = Point{} }
func (m *Point) String() string { return proto.CompactTextString(m) }
func (*Point) ProtoMessage()    {}
func (*Point) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b0d5848323ed639, []int{0}
}

func (m *Point) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Point.Unmarshal(m, b)
}
func (m *Point) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Point.Marshal(b, m, deterministic)
}
func (m *Point) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Point.Merge(m, src)
}
func (m *Point) XXX_Size() int {
	return xxx_messageInfo_Point.Size(m)
}
func (m *Point) XXX_DiscardUnknown() {
	xxx_messageInfo_Point.DiscardUnknown(m)
}

var xxx_messageInfo_Point proto.InternalMessageInfo

func (m *Point) GetPointId() uint64 {
	if m != nil {
		return m.PointId
	}
	return 0
}

func (m *Point) GetLatitude() float64 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *Point) GetLongitude() float64 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *Point) GetAccuracy() float64 {
	if m != nil {
		return m.Accuracy
	}
	return 0
}

type UserPoints struct {
	UserId               uint64   `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	WithDistance         bool     `protobuf:"varint,2,opt,name=with_distance,json=withDistance,proto3" json:"with_distance,omitempty"`
	Items                []*Point `protobuf:"bytes,3,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserPoints) Reset()         { *m = UserPoints{} }
func (m *UserPoints) String() string { return proto.CompactTextString(m) }
func (*UserPoints) ProtoMessage()    {}
func (*UserPoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b0d5848323ed639, []int{1}
}

func (m *UserPoints) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserPoints.Unmarshal(m, b)
}
func (m *UserPoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserPoints.Marshal(b, m, deterministic)
}
func (m *UserPoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPoints.Merge(m, src)
}
func (m *UserPoints) XXX_Size() int {
	return xxx_messageInfo_UserPoints.Size(m)
}
func (m *UserPoints) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPoints.DiscardUnknown(m)
}

var xxx_messageInfo_UserPoints proto.InternalMessageInfo

func (m *UserPoints) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserPoints) GetWithDistance() bool {
	if m != nil {
		return m.WithDistance
	}
	return false
}

func (m *UserPoints) GetItems() []*Point {
	if m != nil {
		return m.Items
	}
	return nil
}

type Points struct {
	Points               []*Point `protobuf:"bytes,1,rep,name=points,proto3" json:"points,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Points) Reset()         { *m = Points{} }
func (m *Points) String() string { return proto.CompactTextString(m) }
func (*Points) ProtoMessage()    {}
func (*Points) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b0d5848323ed639, []int{2}
}

func (m *Points) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Points.Unmarshal(m, b)
}
func (m *Points) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Points.Marshal(b, m, deterministic)
}
func (m *Points) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Points.Merge(m, src)
}
func (m *Points) XXX_Size() int {
	return xxx_messageInfo_Points.Size(m)
}
func (m *Points) XXX_DiscardUnknown() {
	xxx_messageInfo_Points.DiscardUnknown(m)
}

var xxx_messageInfo_Points proto.InternalMessageInfo

func (m *Points) GetPoints() []*Point {
	if m != nil {
		return m.Points
	}
	return nil
}

type PointWithGeofence struct {
	Points               []*Point `protobuf:"bytes,1,rep,name=points,proto3" json:"points,omitempty"`
	GeofenceId           []uint64 `protobuf:"varint,2,rep,packed,name=geofence_id,json=geofenceId,proto3" json:"geofence_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PointWithGeofence) Reset()         { *m = PointWithGeofence{} }
func (m *PointWithGeofence) String() string { return proto.CompactTextString(m) }
func (*PointWithGeofence) ProtoMessage()    {}
func (*PointWithGeofence) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b0d5848323ed639, []int{3}
}

func (m *PointWithGeofence) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PointWithGeofence.Unmarshal(m, b)
}
func (m *PointWithGeofence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PointWithGeofence.Marshal(b, m, deterministic)
}
func (m *PointWithGeofence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PointWithGeofence.Merge(m, src)
}
func (m *PointWithGeofence) XXX_Size() int {
	return xxx_messageInfo_PointWithGeofence.Size(m)
}
func (m *PointWithGeofence) XXX_DiscardUnknown() {
	xxx_messageInfo_PointWithGeofence.DiscardUnknown(m)
}

var xxx_messageInfo_PointWithGeofence proto.InternalMessageInfo

func (m *PointWithGeofence) GetPoints() []*Point {
	if m != nil {
		return m.Points
	}
	return nil
}

func (m *PointWithGeofence) GetGeofenceId() []uint64 {
	if m != nil {
		return m.GeofenceId
	}
	return nil
}

// responses
type GeofenceInfo struct {
	GeofenceId           uint64   `protobuf:"varint,1,opt,name=geofence_id,json=geofenceId,proto3" json:"geofence_id,omitempty"`
	PolygonId            uint64   `protobuf:"varint,2,opt,name=polygon_id,json=polygonId,proto3" json:"polygon_id,omitempty"`
	Title                string   `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	Distance             float64  `protobuf:"fixed64,4,opt,name=distance,proto3" json:"distance,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GeofenceInfo) Reset()         { *m = GeofenceInfo{} }
func (m *GeofenceInfo) String() string { return proto.CompactTextString(m) }
func (*GeofenceInfo) ProtoMessage()    {}
func (*GeofenceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b0d5848323ed639, []int{4}
}

func (m *GeofenceInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GeofenceInfo.Unmarshal(m, b)
}
func (m *GeofenceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GeofenceInfo.Marshal(b, m, deterministic)
}
func (m *GeofenceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeofenceInfo.Merge(m, src)
}
func (m *GeofenceInfo) XXX_Size() int {
	return xxx_messageInfo_GeofenceInfo.Size(m)
}
func (m *GeofenceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GeofenceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GeofenceInfo proto.InternalMessageInfo

func (m *GeofenceInfo) GetGeofenceId() uint64 {
	if m != nil {
		return m.GeofenceId
	}
	return 0
}

func (m *GeofenceInfo) GetPolygonId() uint64 {
	if m != nil {
		return m.PolygonId
	}
	return 0
}

func (m *GeofenceInfo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *GeofenceInfo) GetDistance() float64 {
	if m != nil {
		return m.Distance
	}
	return 0
}

type Geofence struct {
	PointId              uint64          `protobuf:"varint,1,opt,name=point_id,json=pointId,proto3" json:"point_id,omitempty"`
	GeoInfo              []*GeofenceInfo `protobuf:"bytes,2,rep,name=geoInfo,proto3" json:"geoInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Geofence) Reset()         { *m = Geofence{} }
func (m *Geofence) String() string { return proto.CompactTextString(m) }
func (*Geofence) ProtoMessage()    {}
func (*Geofence) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b0d5848323ed639, []int{5}
}

func (m *Geofence) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Geofence.Unmarshal(m, b)
}
func (m *Geofence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Geofence.Marshal(b, m, deterministic)
}
func (m *Geofence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Geofence.Merge(m, src)
}
func (m *Geofence) XXX_Size() int {
	return xxx_messageInfo_Geofence.Size(m)
}
func (m *Geofence) XXX_DiscardUnknown() {
	xxx_messageInfo_Geofence.DiscardUnknown(m)
}

var xxx_messageInfo_Geofence proto.InternalMessageInfo

func (m *Geofence) GetPointId() uint64 {
	if m != nil {
		return m.PointId
	}
	return 0
}

func (m *Geofence) GetGeoInfo() []*GeofenceInfo {
	if m != nil {
		return m.GeoInfo
	}
	return nil
}

type Geofences struct {
	UserId               uint64      `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Geofence             []*Geofence `protobuf:"bytes,2,rep,name=geofence,proto3" json:"geofence,omitempty"`
	Status               Status      `protobuf:"varint,3,opt,name=status,proto3,enum=geofence.Status" json:"status,omitempty"`
	Error                string      `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Geofences) Reset()         { *m = Geofences{} }
func (m *Geofences) String() string { return proto.CompactTextString(m) }
func (*Geofences) ProtoMessage()    {}
func (*Geofences) Descriptor() ([]byte, []int) {
	return fileDescriptor_9b0d5848323ed639, []int{6}
}

func (m *Geofences) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Geofences.Unmarshal(m, b)
}
func (m *Geofences) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Geofences.Marshal(b, m, deterministic)
}
func (m *Geofences) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Geofences.Merge(m, src)
}
func (m *Geofences) XXX_Size() int {
	return xxx_messageInfo_Geofences.Size(m)
}
func (m *Geofences) XXX_DiscardUnknown() {
	xxx_messageInfo_Geofences.DiscardUnknown(m)
}

var xxx_messageInfo_Geofences proto.InternalMessageInfo

func (m *Geofences) GetUserId() uint64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Geofences) GetGeofence() []*Geofence {
	if m != nil {
		return m.Geofence
	}
	return nil
}

func (m *Geofences) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_OK
}

func (m *Geofences) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func init() {
	proto.RegisterEnum("geofence.Status", Status_name, Status_value)
	proto.RegisterType((*Point)(nil), "geofence.Point")
	proto.RegisterType((*UserPoints)(nil), "geofence.UserPoints")
	proto.RegisterType((*Points)(nil), "geofence.Points")
	proto.RegisterType((*PointWithGeofence)(nil), "geofence.PointWithGeofence")
	proto.RegisterType((*GeofenceInfo)(nil), "geofence.GeofenceInfo")
	proto.RegisterType((*Geofence)(nil), "geofence.Geofence")
	proto.RegisterType((*Geofences)(nil), "geofence.Geofences")
}

func init() { proto.RegisterFile("geofences.proto", fileDescriptor_9b0d5848323ed639) }

var fileDescriptor_9b0d5848323ed639 = []byte{
	// 541 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0x5f, 0x8f, 0xd2, 0x4e,
	0x14, 0xdd, 0xf2, 0xa7, 0xd0, 0x0b, 0xfb, 0xa3, 0xbf, 0x91, 0x55, 0x76, 0xd5, 0x48, 0x6a, 0x8c,
	0xc4, 0x87, 0x46, 0xf1, 0xd1, 0x17, 0x97, 0xa5, 0x92, 0xba, 0x06, 0x74, 0x00, 0x37, 0x31, 0x31,
	0x4d, 0x6d, 0x67, 0xa1, 0x11, 0x3b, 0xd8, 0x19, 0x54, 0xde, 0xfc, 0x10, 0x7e, 0x44, 0x3f, 0x88,
	0xe9, 0x4c, 0xa7, 0x25, 0xac, 0xbb, 0xf1, 0xad, 0xf7, 0x9c, 0x7b, 0xcf, 0xdc, 0x33, 0xf7, 0x4e,
	0xa1, 0xb5, 0x20, 0xf4, 0x92, 0xc4, 0x01, 0x61, 0xf6, 0x3a, 0xa1, 0x9c, 0xa2, 0xba, 0x02, 0xac,
	0x1f, 0x50, 0x7d, 0x4b, 0xa3, 0x98, 0xa3, 0x63, 0xa8, 0xaf, 0xd3, 0x0f, 0x2f, 0x0a, 0x3b, 0x5a,
	0x57, 0xeb, 0x55, 0x70, 0x4d, 0xc4, 0x6e, 0x88, 0x4e, 0xa0, 0xbe, 0xf2, 0x79, 0xc4, 0x37, 0x21,
	0xe9, 0x94, 0xba, 0x5a, 0x4f, 0xc3, 0x79, 0x8c, 0xee, 0x81, 0xb1, 0xa2, 0xf1, 0x42, 0x92, 0x65,
	0x41, 0x16, 0x40, 0x5a, 0xe9, 0x07, 0xc1, 0x26, 0xf1, 0x83, 0x6d, 0xa7, 0x22, 0x2b, 0x55, 0x6c,
	0x7d, 0x05, 0x98, 0x33, 0x92, 0x88, 0xd3, 0x19, 0xba, 0x03, 0xb5, 0x0d, 0x23, 0x49, 0x71, 0xba,
	0x9e, 0x86, 0x6e, 0x88, 0x1e, 0xc2, 0xe1, 0xf7, 0x88, 0x2f, 0xbd, 0x30, 0x62, 0xdc, 0x8f, 0x03,
	0xd9, 0x41, 0x1d, 0x37, 0x53, 0x70, 0x98, 0x61, 0xe8, 0x11, 0x54, 0x23, 0x4e, 0xbe, 0xb0, 0x4e,
	0xb9, 0x5b, 0xee, 0x35, 0xfa, 0x2d, 0x5b, 0xf9, 0xb3, 0x85, 0x3c, 0x96, 0xac, 0xf5, 0x0c, 0xf4,
	0xec, 0xb8, 0xc7, 0xa0, 0x0b, 0x77, 0xac, 0xa3, 0xfd, 0xbd, 0x22, 0xa3, 0xad, 0x8f, 0xf0, 0xbf,
	0x00, 0x2e, 0x22, 0xbe, 0x1c, 0x65, 0x29, 0xff, 0x5c, 0x8d, 0x1e, 0x40, 0x43, 0x31, 0xa9, 0xb3,
	0x52, 0xb7, 0xdc, 0xab, 0x60, 0x50, 0x90, 0x1b, 0x5a, 0x3f, 0x35, 0x68, 0x2a, 0x59, 0x37, 0xbe,
	0xa4, 0xfb, 0x15, 0xf2, 0x2e, 0x76, 0x2a, 0xd0, 0x7d, 0x80, 0x35, 0x5d, 0x6d, 0x17, 0x34, 0x96,
	0x8a, 0x29, 0x6f, 0x64, 0x88, 0x1b, 0xa2, 0x36, 0x54, 0x79, 0xc4, 0x57, 0x72, 0x16, 0x06, 0x96,
	0x41, 0x3a, 0x87, 0xfc, 0xfe, 0xb2, 0x39, 0xa8, 0xd8, 0xba, 0x80, 0x7a, 0x6e, 0xec, 0x86, 0x25,
	0x78, 0x0a, 0xb5, 0x05, 0xa1, 0x69, 0x8f, 0xc2, 0x46, 0xa3, 0x7f, 0xbb, 0x30, 0xbd, 0xeb, 0x00,
	0xab, 0x34, 0xeb, 0x97, 0x06, 0x86, 0x62, 0x6e, 0x18, 0xb0, 0x0d, 0xf9, 0x36, 0x66, 0xca, 0xe8,
	0xaa, 0x32, 0xce, 0x73, 0x50, 0x0f, 0x74, 0xc6, 0x7d, 0xbe, 0x61, 0xc2, 0xe2, 0x7f, 0x7d, 0xb3,
	0xc8, 0x9e, 0x0a, 0x1c, 0x67, 0x7c, 0x7a, 0x17, 0x24, 0x49, 0x68, 0x22, 0x2c, 0x1b, 0x58, 0x06,
	0x4f, 0xce, 0x41, 0x97, 0x79, 0x48, 0x87, 0xd2, 0xe4, 0xdc, 0x3c, 0x40, 0x87, 0x60, 0x8c, 0x27,
	0x33, 0xef, 0xd5, 0x64, 0x3e, 0x1e, 0x9a, 0x1a, 0x6a, 0x41, 0x63, 0x70, 0x3a, 0xf4, 0xb0, 0xf3,
	0x6e, 0xee, 0x4c, 0x67, 0x66, 0x09, 0x1d, 0xc3, 0x91, 0x3b, 0x9e, 0x39, 0x78, 0x7c, 0xfa, 0xc6,
	0x9b, 0x3a, 0xf8, 0xbd, 0x83, 0x3d, 0x07, 0xe3, 0x09, 0x36, 0xcb, 0xfd, 0xdf, 0x1a, 0xb4, 0x54,
	0x8f, 0x53, 0x92, 0x7c, 0x8b, 0x02, 0x82, 0xce, 0xa0, 0x3d, 0x22, 0x3c, 0x77, 0x3e, 0xd8, 0xce,
	0xa5, 0xd1, 0x76, 0xd1, 0x68, 0xb1, 0xf8, 0x27, 0xb7, 0xae, 0x9a, 0x65, 0xd6, 0x01, 0x7a, 0x0d,
	0xed, 0xb3, 0x25, 0x09, 0x3e, 0x2b, 0x6c, 0xb0, 0x95, 0xcf, 0xf4, 0xee, 0xde, 0xaa, 0xed, 0xee,
	0xe5, 0x75, 0x5a, 0x2f, 0xe1, 0x68, 0x44, 0xb8, 0x7a, 0x2c, 0x33, 0x9a, 0x8f, 0xdb, 0xdc, 0x13,
	0xbb, 0xae, 0x9b, 0x41, 0xf3, 0x03, 0xd8, 0x2f, 0x14, 0xf3, 0x49, 0x17, 0x3f, 0x91, 0xe7, 0x7f,
	0x02, 0x00, 0x00, 0xff, 0xff, 0x3d, 0x02, 0xad, 0x1d, 0x57, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GeofenceServiceClient is the client API for GeofenceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GeofenceServiceClient interface {
	GetGeofencesByUserId(ctx context.Context, in *UserPoints, opts ...grpc.CallOption) (*Geofences, error)
	CheckGeofenceByPoint(ctx context.Context, in *PointWithGeofence, opts ...grpc.CallOption) (*Geofences, error)
	GetDistanceToGeofence(ctx context.Context, in *Points, opts ...grpc.CallOption) (*Geofences, error)
}

type geofenceServiceClient struct {
	cc *grpc.ClientConn
}

func NewGeofenceServiceClient(cc *grpc.ClientConn) GeofenceServiceClient {
	return &geofenceServiceClient{cc}
}

func (c *geofenceServiceClient) GetGeofencesByUserId(ctx context.Context, in *UserPoints, opts ...grpc.CallOption) (*Geofences, error) {
	out := new(Geofences)
	err := c.cc.Invoke(ctx, "/geofence.GeofenceService/GetGeofencesByUserId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geofenceServiceClient) CheckGeofenceByPoint(ctx context.Context, in *PointWithGeofence, opts ...grpc.CallOption) (*Geofences, error) {
	out := new(Geofences)
	err := c.cc.Invoke(ctx, "/geofence.GeofenceService/CheckGeofenceByPoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geofenceServiceClient) GetDistanceToGeofence(ctx context.Context, in *Points, opts ...grpc.CallOption) (*Geofences, error) {
	out := new(Geofences)
	err := c.cc.Invoke(ctx, "/geofence.GeofenceService/GetDistanceToGeofence", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GeofenceServiceServer is the server API for GeofenceService service.
type GeofenceServiceServer interface {
	GetGeofencesByUserId(context.Context, *UserPoints) (*Geofences, error)
	CheckGeofenceByPoint(context.Context, *PointWithGeofence) (*Geofences, error)
	GetDistanceToGeofence(context.Context, *Points) (*Geofences, error)
}

// UnimplementedGeofenceServiceServer can be embedded to have forward compatible implementations.
type UnimplementedGeofenceServiceServer struct {
}

func (*UnimplementedGeofenceServiceServer) GetGeofencesByUserId(ctx context.Context, req *UserPoints) (*Geofences, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGeofencesByUserId not implemented")
}
func (*UnimplementedGeofenceServiceServer) CheckGeofenceByPoint(ctx context.Context, req *PointWithGeofence) (*Geofences, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckGeofenceByPoint not implemented")
}
func (*UnimplementedGeofenceServiceServer) GetDistanceToGeofence(ctx context.Context, req *Points) (*Geofences, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDistanceToGeofence not implemented")
}

func RegisterGeofenceServiceServer(s *grpc.Server, srv GeofenceServiceServer) {
	s.RegisterService(&_GeofenceService_serviceDesc, srv)
}

func _GeofenceService_GetGeofencesByUserId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserPoints)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeofenceServiceServer).GetGeofencesByUserId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geofence.GeofenceService/GetGeofencesByUserId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeofenceServiceServer).GetGeofencesByUserId(ctx, req.(*UserPoints))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeofenceService_CheckGeofenceByPoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PointWithGeofence)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeofenceServiceServer).CheckGeofenceByPoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geofence.GeofenceService/CheckGeofenceByPoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeofenceServiceServer).CheckGeofenceByPoint(ctx, req.(*PointWithGeofence))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeofenceService_GetDistanceToGeofence_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Points)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeofenceServiceServer).GetDistanceToGeofence(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/geofence.GeofenceService/GetDistanceToGeofence",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeofenceServiceServer).GetDistanceToGeofence(ctx, req.(*Points))
	}
	return interceptor(ctx, in, info, handler)
}

var _GeofenceService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "geofence.GeofenceService",
	HandlerType: (*GeofenceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetGeofencesByUserId",
			Handler:    _GeofenceService_GetGeofencesByUserId_Handler,
		},
		{
			MethodName: "CheckGeofenceByPoint",
			Handler:    _GeofenceService_CheckGeofenceByPoint_Handler,
		},
		{
			MethodName: "GetDistanceToGeofence",
			Handler:    _GeofenceService_GetDistanceToGeofence_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "geofences.proto",
}
